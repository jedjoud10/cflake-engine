#version 460 core
layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

// Data generated by the voxel comupute shader
layout(set = 0, binding = 0, r32f) readonly uniform image3D densities;

// Texture that contains the index of each vertex
layout(set = 0, binding = 1, r32ui) uniform uimage3D cached_indices;

// Output vertices
layout(std430, set = 1, binding = 0) writeonly buffer Vertices {
    vec4 data[64*64*64];
} vertices;

// Output normals
layout(std430, set = 1, binding = 1) writeonly buffer Normals {
    vec4 data[64*64*64];
} normals;

// Atomic counters
layout(std430, set = 0, binding = 2) buffer Counters {
    uint vertices;
    uint triangles;
} counters;

// Positions of the first vertex in edges
uvec3 edge_positions1[12] = {
    uvec3(0, 1, 0),
    uvec3(1, 1, 0),
    uvec3(1, 0, 0),
    uvec3(1, 0, 0),
    uvec3(0, 1, 1),
    uvec3(1, 1, 1),
    uvec3(1, 0, 1),
    uvec3(0, 0, 1),
    uvec3(0, 0, 1),
    uvec3(0, 1, 1),
    uvec3(1, 1, 1),
    uvec3(1, 0, 1),
};

// Positions of the second vertex in edges
uvec3 edge_positions2[12] = {
    uvec3(0, 0, 0),
    uvec3(0, 1, 0),
    uvec3(1, 1, 0),
    uvec3(0, 0, 0),
    uvec3(0, 0, 1),
    uvec3(0, 1, 1),
    uvec3(1, 1, 1),
    uvec3(1, 0, 1),
    uvec3(0, 0, 0),
    uvec3(0, 1, 0),
    uvec3(1, 1, 0),
    uvec3(1, 0, 0),
};

// Takes two values and find where x lies on them (0 - 1 range)
float unmix(float a, float b, float x)
{
    return (x - a) / (b - a);
}

void main() {
    // Do an average sum to get vertex location 
    vec3 sum = vec3(0);
    uint count = 0;
    
    // Check each edge in the cell for intersections
    for (int edge = 0; edge < 12; edge++) {
        uvec3 start = edge_positions1[edge] + gl_GlobalInvocationID;
        uvec3 end = edge_positions2[edge] + gl_GlobalInvocationID;

        // Get the densities of the edge
        float density1 = imageLoad(densities, ivec3(start)).x;
        float density2 = imageLoad(densities, ivec3(end)).x;

        // Create a vertex on the line of the edge
        if ((density1 > 0.0 ^^ density2 > 0.0)) {
            // Find the lerp factor for the iso-threshold value 
            float value = unmix(density1, density2, 0.0);
            
            // Calculate vertex along the edge
            vec3 interpolated = mix(vec3(edge_positions1[edge]), vec3(edge_positions2[edge]), value);

            sum += interpolated;
            count += 1;
        }
    }

    // Note: For some reason, when debugging this shader in renderdoc the output texture would look messed up
    // and it would hint that there's some sort of duplicate vertices. I've checked manually and the reason this happens is because it's a bug within renderdoc
    // whenever the user uses a push constant in the compute shader the whole thing just breaks and outputs wrong debug textures, but within the engine it works perfectly fine

    // If we found at least one intersecting edge, add the vertex
    if (count > 0) {
        uint index = atomicAdd(counters.vertices, 1);
        vertices.data[index] = vec4(sum / count, 0) + vec4(gl_GlobalInvocationID, 0);
        normals.data[index] = vec4(gl_GlobalInvocationID+1, 0.0);
        imageStore(cached_indices, ivec3(gl_GlobalInvocationID+1), uvec4(index));
    }
}