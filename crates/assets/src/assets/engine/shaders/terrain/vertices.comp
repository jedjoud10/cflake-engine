#version 460 core
layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

// TODO: Please implement spec constants instead of this shit
#include "size"
#include "smoothing"

// Data generated by the voxel comupute shader
layout(set = 0, binding = 0, r32f) readonly uniform image3D densities;

// Texture that contains the index of each vertex
layout(set = 0, binding = 1, r32ui) uniform uimage3D cached_indices;

// Output vertices
layout(std430, set = 1, binding = 0) writeonly buffer Vertices {
    vec4 data[size*size*size];
} vertices;

// Output normals
layout(std430, set = 1, binding = 1) writeonly buffer Normals {
    uvec4 data[size*size*size];
} normals;

// Atomic counters
layout(std430, set = 0, binding = 2) buffer Counters {
    uint vertices;
    uint triangles;
} counters;

// Positions of the first vertex in edges
uvec3 edge_positions1[12] = {
    uvec3(0, 1, 0),
    uvec3(1, 1, 0),
    uvec3(1, 0, 0),
    uvec3(1, 0, 0),
    uvec3(0, 1, 1),
    uvec3(1, 1, 1),
    uvec3(1, 0, 1),
    uvec3(0, 0, 1),
    uvec3(0, 0, 1),
    uvec3(0, 1, 1),
    uvec3(1, 1, 1),
    uvec3(1, 0, 1),
};

// Positions of the second vertex in edges
uvec3 edge_positions2[12] = {
    uvec3(0, 0, 0),
    uvec3(0, 1, 0),
    uvec3(1, 1, 0),
    uvec3(0, 0, 0),
    uvec3(0, 0, 1),
    uvec3(0, 1, 1),
    uvec3(1, 1, 1),
    uvec3(1, 0, 1),
    uvec3(0, 0, 0),
    uvec3(0, 1, 0),
    uvec3(1, 1, 0),
    uvec3(1, 0, 0),
};

// Calculate normals for a specific coordinate using the density texture
vec3 calculate_normal(uvec3 position) {
    float density0 = imageLoad(densities, ivec3(position)).x;
    float density1 = imageLoad(densities, ivec3(position) + ivec3(1, 0, 0)).x;
    float density2 = imageLoad(densities, ivec3(position) + ivec3(0, 1, 0)).x;
    float density3 = imageLoad(densities, ivec3(position) + ivec3(0, 0, 1)).x;
    return vec3(
        density0 - density1,
        density0 - density2,
        density0 - density3
    );
}

// Takes two values and find where x lies on them (0 - 1 range)
float unmix(float a, float b, float x)
{
    return (x - a) / (b - a);
}

void main() {
    // Do an average sum to get vertex location 
    vec3 vertex = vec3(0);
    uint count = 0;

    // Do an average sum to get normals
    vec3 normal = vec3(0);
    
    // Check each edge in the cell for intersections
    for (int edge = 0; edge < 12; edge++) {
        uvec3 start = edge_positions1[edge] + gl_GlobalInvocationID;
        uvec3 end = edge_positions2[edge] + gl_GlobalInvocationID;

        // Get the densities of the edge
        float density1 = imageLoad(densities, ivec3(start)).x;
        float density2 = imageLoad(densities, ivec3(end)).x;

        // Create a vertex on the line of the edge
        if ((density1 > 0.0 ^^ density2 > 0.0)) {
            // Find the lerp factor for the iso-threshold value 
            float value = unmix(density1, density2, 0.0);

            // Calculate vertex along the edge
            vertex += mix(vec3(edge_positions1[edge]), vec3(edge_positions2[edge]), value);

            // Calculate the normal for the first and second corners
            vec3 normal0 = calculate_normal(start);
            vec3 normal1 = calculate_normal(end);

            // Calculate normal along the edge
            normal += mix(normal0, normal1, value);
            count += 1;
        }
    }

    // Note: For some reason, when debugging this shader in renderdoc the output texture would look messed up
    // and it would hint that there's some sort of duplicate vertices. I've checked manually and the reason this happens is because it's a bug within renderdoc
    // whenever the user uses a push constant in the compute shader the whole thing just breaks and outputs wrong debug textures, but within the engine it works perfectly fine

    // If we found at least one intersecting edge, add the vertex
    if (count > 0) {
        uint index = atomicAdd(counters.vertices, 1);

        // Meshes are always n-2 size, so each voxel has a size of 1 / n-2
        vec3 final = (smoothing ? (vertex / count) : vec3(gl_GlobalInvocationID)) + vec3(gl_GlobalInvocationID);
        float factor = (float(size)) / (float(size) - 2);
        vertices.data[index] = vec4(final * factor, 0);
        
        // We have to do this since we store the normal data as 4 signed normalized bytes, and glsl doesn't have a byte vector 4
        //ivec3 ranged = normal * 127;
        //uint compressed = uint(normal.y * 127);        
        normals.data[index / 4][index % 4] = packSnorm4x8(vec4(normal, 0.0));


        imageStore(cached_indices, ivec3(gl_GlobalInvocationID+1), uvec4(index));
    }
}