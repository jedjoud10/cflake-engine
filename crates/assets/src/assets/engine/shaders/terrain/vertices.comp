#version 460 core
layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

// Spec constants for params
layout (constant_id = 0) const uint size = 1;
layout (constant_id = 1) const bool blocky = true;

// Needed for skirts
layout(push_constant) uniform PushConstants {
    // Bitflags containing what skirts should be enabled
    // Bit 1 = Start X
    // Bit 2 = Start Y
    // Bit 3 = Start Z
    // Bit 4 = End X
    // Bit 5 = End Y
    // Bit 6 = End Z
    uint skirts_direction_bitflags;
} meshing;

#include <engine/shaders/math/packer.glsl>

// Data generated by the voxel comupute shader
layout(set = 0, binding = 0, rg32f) readonly uniform image3D voxels;

// Texture that contains the index of each vertex
layout(set = 0, binding = 3, r32ui) uniform uimage3D cached_indices;

// Output temp vertices
layout(std430, set = 1, binding = 0) writeonly buffer Vertices {
    vec4 data[size*size*size];
} vertices;

// Atomic counters
layout(std430, set = 0, binding = 4) buffer Counters {
    uint vertices;
    uint triangles;
} counters;

// Positions of the first vertex in edges
uvec3 edge_positions1[12] = {
    uvec3(0, 1, 0),
    uvec3(1, 1, 0),
    uvec3(1, 0, 0),
    uvec3(1, 0, 0),
    uvec3(0, 1, 1),
    uvec3(1, 1, 1),
    uvec3(1, 0, 1),
    uvec3(0, 0, 1),
    uvec3(0, 0, 1),
    uvec3(0, 1, 1),
    uvec3(1, 1, 1),
    uvec3(1, 0, 1),
};

// Positions of the second vertex in edges
uvec3 edge_positions2[12] = {
    uvec3(0, 0, 0),
    uvec3(0, 1, 0),
    uvec3(1, 1, 0),
    uvec3(0, 0, 0),
    uvec3(0, 0, 1),
    uvec3(0, 1, 1),
    uvec3(1, 1, 1),
    uvec3(1, 0, 1),
    uvec3(0, 0, 0),
    uvec3(0, 1, 0),
    uvec3(1, 1, 0),
    uvec3(1, 0, 0),
};

// Calculate normals for a specific coordinate using the density texture
vec3 calculate_normal(uvec3 position) {
    float density0 = imageLoad(voxels, ivec3(position)).x;
    float density1 = imageLoad(voxels, ivec3(position) + ivec3(1, 0, 0)).x;
    float density2 = imageLoad(voxels, ivec3(position) + ivec3(0, 1, 0)).x;
    float density3 = imageLoad(voxels, ivec3(position) + ivec3(0, 0, 1)).x;
    return vec3(
        density0 - density1,
        density0 - density2,
        density0 - density3
    );
}

// Takes two values and find where x lies on them (0 - 1 range)
float unmix(float a, float b, float x)
{
    return (x - a) / (b - a);
}

void main() {
    // Required to remove the false positive
    if (any(greaterThanEqual(ivec3(gl_GlobalInvocationID), ivec3(size-2)))) {
        return;
    }

    // Do an average sum to get vertex location 
    vec3 vertex = vec3(0);
    uint count = 0;

    // Do an average sum to get normals
    #ifndef lowpoly
    vec3 normal = vec3(0);
    #endif

    // Check each edge in the cell for intersections
    for (int edge = 0; edge < 12; edge++) {
        uvec3 start = edge_positions1[edge] + gl_GlobalInvocationID;
        uvec3 end = edge_positions2[edge] + gl_GlobalInvocationID;

        // Get the densities of the edge
        float density1 = imageLoad(voxels, ivec3(start)).x;
        float density2 = imageLoad(voxels, ivec3(end)).x;

        // Create a vertex on the line of the edge
        if ((density1 > 0.0 ^^ density2 > 0.0)) {
            // Find the lerp factor for the iso-threshold value 
            float value = unmix(density1, density2, 0.0);

            // Calculate vertex along the edge
            vertex += mix(vec3(edge_positions1[edge]), vec3(edge_positions2[edge]), value);

            // Calculate the normal for the first and second corners
            #ifndef lowpoly
            vec3 normal0 = calculate_normal(start);
            vec3 normal1 = calculate_normal(end);
            normal += mix(normal0, normal1, value);
            #endif

            // Do NOT forget to increment    
            count += 1;
        }
    }

    /*
    // Check if we are genearting some skirts
    bool skirts = any(lessThanEqual(gl_GlobalInvocationID, vec3(1))) || any(greaterThanEqual(gl_GlobalInvocationID, vec3(size-3)));

    // Update normals and count for skirts
    if (skirts && imageLoad(voxels, ivec3(gl_GlobalInvocationID)).x < 0.0) {
        normal = calculate_normal(gl_GlobalInvocationID) * 4;
        count = 4;
    }
    */

    // If we found at least one intersecting edge, add the vertex
    if (count > 0) {
        uint index = atomicAdd(counters.vertices, 1);

        #ifndef lowpoly
        // Stored in the first 16 bits
        uint packed_normals = cube_16(normalize(normal / count));
        #else
        uint packed_normals = 0;
        #endif

        // Meshes are always n-3 size, so each voxel has a size of 1 / n-3
        vec3 final = blocky ? vec3(0) : ((vertex / count) - vec3(0.5));

        // Decompose the bitflags into booleans
        uint bits = meshing.skirts_direction_bitflags;
        bool start_x = (bits & 1) == 1;
        bool start_y = (bits & 2) == 1;
        bool start_z = (bits & 4) == 1;
        bool end_x = (bits & 8) == 1;
        bool end_y = (bits & 16) == 1;
        bool end_z = (bits & 32) == 1;

        start_x = true;
        start_y = true;
        start_z = true;
        end_x = true;
        end_y = true;
        end_z = true;


        // TODO: Probably a way to optimize this
        // Confine the vertices in the X skirt if needed
        /*
        if ((gl_GlobalInvocationID.x < 1 && start_x)  || (gl_GlobalInvocationID.x == size-3 && end_x) ) {
            final.x = 0;
        }
        */

        /*
        // Confine the vertices in the Y skirt if needed
        if ((gl_GlobalInvocationID.y < 1 && start_y) || (gl_GlobalInvocationID.y == size-3 && end_y)) {
            final.y = 0;
        }

        // Confine the vertices in the Z skirt if needed
        if ((gl_GlobalInvocationID.z < 1 && start_z) || (gl_GlobalInvocationID.z == size-3 && end_z)) {
            final.z = 0;
        }
        */

        // Positions only need 16 bits (1 byte for cell coord, 1 byte for inner vertex coord)
        uint packed_cell_position_packed_normals = packUnorm4x8(vec4(gl_GlobalInvocationID, 0) / 255);
        uint packed_inner_position_packed_normals = packSnorm4x8(vec4(final, 0));
        packed_cell_position_packed_normals = packed_cell_position_packed_normals | ((packed_normals & 0xFF00) >> 8) << 24;
        packed_inner_position_packed_normals = packed_inner_position_packed_normals | (packed_normals & 0xFF) << 24;

        // Convert to 4 floats to store within the texture
        float float_packed_cell_position_packed_normals = uintBitsToFloat(packed_cell_position_packed_normals);
        float float_packed_inner_position_packed_normals = uintBitsToFloat(packed_inner_position_packed_normals);

        // Store the packed positions and normals
        vertices.data[index] = vec4(
            float_packed_cell_position_packed_normals,
            float_packed_inner_position_packed_normals,
            0, 0
        );

        imageStore(cached_indices, ivec3(gl_GlobalInvocationID + 1), uvec4(index));
    }
}