#version 460 core
layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

// Spec constants for params
layout (constant_id = 0) const uint size = 1;
layout (constant_id = 1) const bool blocky = true;

#include <engine/shaders/math/packer.glsl>

// Data generated by the voxel comupute shader
layout(set = 0, binding = 0, rg32f) readonly uniform image3D voxels;

// Texture that contains the index of each vertex
layout(set = 0, binding = 3, r32ui) uniform uimage3D cached_indices;

// Output temp vertices
layout(std430, set = 1, binding = 0) writeonly buffer Vertices {
    vec2 data[size*size*size];
} vertices;

// Atomic counters
layout(std430, set = 0, binding = 4) buffer Counters {
    uint vertices;
    uint triangles;
} counters;

// Positions of the first vertex in edges
uvec3 edge_positions1[12] = {
    uvec3(0, 1, 0),
    uvec3(1, 1, 0),
    uvec3(1, 0, 0),
    uvec3(1, 0, 0),
    uvec3(0, 1, 1),
    uvec3(1, 1, 1),
    uvec3(1, 0, 1),
    uvec3(0, 0, 1),
    uvec3(0, 0, 1),
    uvec3(0, 1, 1),
    uvec3(1, 1, 1),
    uvec3(1, 0, 1),
};

// Positions of the second vertex in edges
uvec3 edge_positions2[12] = {
    uvec3(0, 0, 0),
    uvec3(0, 1, 0),
    uvec3(1, 1, 0),
    uvec3(0, 0, 0),
    uvec3(0, 0, 1),
    uvec3(0, 1, 1),
    uvec3(1, 1, 1),
    uvec3(1, 0, 1),
    uvec3(0, 0, 0),
    uvec3(0, 1, 0),
    uvec3(1, 1, 0),
    uvec3(1, 0, 0),
};

// Calculate normals for a specific coordinate using the density texture
vec3 calculate_normal(uvec3 position) {
    float density0 = imageLoad(voxels, ivec3(position)).x;
    float density1 = imageLoad(voxels, ivec3(position) + ivec3(1, 0, 0)).x;
    float density2 = imageLoad(voxels, ivec3(position) + ivec3(0, 1, 0)).x;
    float density3 = imageLoad(voxels, ivec3(position) + ivec3(0, 0, 1)).x;
    return vec3(
        density0 - density1,
        density0 - density2,
        density0 - density3
    );
}

// Takes two values and find where x lies on them (0 - 1 range)
float unmix(float a, float b, float x)
{
    return (x - a) / (b - a);
}

void main() {
    // Required to remove the false positive
    if (any(greaterThanEqual(ivec3(gl_GlobalInvocationID), ivec3(size-2)))) {
        return;
    }

    // Do an average sum to get vertex location 
    vec3 vertex = vec3(0);
    uint count = 0;

    // Do an average sum to get normals
    #ifndef lowpoly
    vec3 normal = vec3(0);
    #endif

    // Check each edge in the cell for intersections
    for (int edge = 0; edge < 12; edge++) {
        uvec3 start = edge_positions1[edge] + gl_GlobalInvocationID;
        uvec3 end = edge_positions2[edge] + gl_GlobalInvocationID;

        // Get the densities of the edge
        float density1 = imageLoad(voxels, ivec3(start)).x;
        float density2 = imageLoad(voxels, ivec3(end)).x;

        // Create a vertex on the line of the edge
        if ((density1 > 0.0 ^^ density2 > 0.0)) {
            // Find the lerp factor for the iso-threshold value 
            float value = unmix(density1, density2, 0.0);

            // Calculate vertex along the edge
            vertex += mix(vec3(edge_positions1[edge]), vec3(edge_positions2[edge]), value);

            // Calculate the normal for the first and second corners
            #ifndef lowpoly
            vec3 normal0 = calculate_normal(start);
            vec3 normal1 = calculate_normal(end);
            normal += mix(normal0, normal1, value);
            #endif

            // Do NOT forget to increment    
            count += 1;
        }
    }

    // Note: For some reason, when debugging this shader in renderdoc the output texture would look messed up
    // and it would hint that there's some sort of duplicate vertices. I've checked manually and the reason this happens is because it's a bug within renderdoc
    // whenever the user uses a push constant in the compute shader the whole thing just breaks and outputs wrong debug textures, but within the engine it works perfectly fine

    // If we found at least one intersecting edge, add the vertex
    if (count > 0) {
        uint index = atomicAdd(counters.vertices, 1);

        #ifndef lowpoly
        // Stored in the first 16 bits
        uint packed_normals = cube_16(normalize(normal / count));
        #else
        uint packed_normals = 0;
        #endif

        // Meshes are always n-3 size, so each voxel has a size of 1 / n-3
        vec3 final = blocky ? vec3(0) : ((vertex / count) - vec3(0.5));

        // Positions only need 16 bits (1 byte for cell coord, 1 byte for inner vertex coord)
        uint packed_cell_position_packed_normals = packUnorm4x8(vec4(gl_GlobalInvocationID, 0) / 255);
        uint packed_inner_position_packed_normals = packSnorm4x8(vec4(final, 0));
        packed_cell_position_packed_normals = packed_cell_position_packed_normals | ((packed_normals & 0xFF00) >> 8) << 24;
        packed_inner_position_packed_normals = packed_inner_position_packed_normals | (packed_normals & 0xFF) << 24;

        // Convert to 4 floats to store within the texture
        float float_packed_cell_position_packed_normals = uintBitsToFloat(packed_cell_position_packed_normals);
        float float_packed_inner_position_packed_normals = uintBitsToFloat(packed_inner_position_packed_normals);

        // Store the packed positions and normals
        vertices.data[index] = vec2(
            float_packed_cell_position_packed_normals,
            float_packed_inner_position_packed_normals
        );

        imageStore(cached_indices, ivec3(gl_GlobalInvocationID+1), uvec4(index));
    }
}