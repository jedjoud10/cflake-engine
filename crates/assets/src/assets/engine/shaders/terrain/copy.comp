#version 460 core
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Spec constants for sizes
layout (constant_id = 0) const uint size = 1;
layout (constant_id = 1) const uint output_vertices_count = 1;
layout (constant_id = 2) const uint output_triangles_count = 1;

// Contains the chunk index
layout(push_constant) uniform PushConstants {
    uint global_chunk_index;
} push_constants;

// Input temp vertices
layout(std430, set = 0, binding = 1) readonly buffer TemporaryVertices {
    vec4 data[size*size*size];
} temporary_vertices;

// Input temp triangles
layout(std430, set = 0, binding = 2) readonly buffer TemporaryTriangles {
    uint data[(size - 1)*(size - 1)*(size - 1)*4*6];
} temporary_triangles;

// Output vertices
layout(std430, set = 1, binding = 1) writeonly buffer OutputVertices {
    vec4 data[output_vertices_count];
} output_vertices;

// Output triangles
layout(std430, set = 1, binding = 2) writeonly buffer OutputTriangles {
    uint data[output_triangles_count];
} output_triangles;

// Allocation offsets
layout(std430, set = 0, binding = 3) readonly buffer FoundOffsets {
    uint vertices;
    uint triangles;
} offsets;

// Atomic counters
layout(std430, set = 0, binding = 4) readonly buffer Counters {
    uint vertices;
    uint triangles;
} counters;

struct IndexedIndirectDrawArgs {
    uint vertex_count;
    uint instance_count;
    uint base_index;
    int vertex_offset;
    uint base_instance;
};

// Indirect drawing buffer
layout(std430, set = 1, binding = 0) writeonly buffer IndirectBuffer {
    IndexedIndirectDrawArgs data[];
} indirect;

void main() {
    uint added_vertices = counters.vertices;
    uint added_triangles = counters.triangles;
    uint vertex_offset = offsets.vertices;
    uint triangle_offset = offsets.triangles;

    // Copy the vertices into the appropriate location within the allocation buffer
    if (gl_GlobalInvocationID.x < added_vertices) {
        output_vertices.data[gl_GlobalInvocationID.x + vertex_offset] = temporary_vertices.data[gl_GlobalInvocationID.x];
    }

    // Copy the triangles into the appropriate location within the allocation buffer
    if (gl_GlobalInvocationID.x < added_triangles) {
        output_triangles.data[gl_GlobalInvocationID.x + triangle_offset] = temporary_triangles.data[gl_GlobalInvocationID.x];
    }

    // Set the indirect draw data
    indirect.data[push_constants.global_chunk_index].base_index = triangle_offset;
    indirect.data[push_constants.global_chunk_index].vertex_offset = int(vertex_offset);
    indirect.data[push_constants.global_chunk_index].vertex_count = counters.triangles;
}