#version 460 core
layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

#extension GL_KHR_memory_scope_semantics : require

// Data generated by the voxel comupute shader
layout(set = 0, binding = 0, r32f) readonly uniform image3D densities;

// Texture that contains the index of each vertex
layout(set = 0, binding = 1, r32ui) uniform uimage3D cached_indices;

// Output vertices
layout(std430, set = 1, binding = 0) writeonly buffer Vertices {
    vec3 data[64*64*64];
} vertices;

// Output triangles
layout(std430, set = 1, binding = 1) writeonly buffer Triangles {
    uint data[63*63*63*4];
} triangles;

// Atomic counters
layout(std430, set = 0, binding = 4) buffer Counters {
    uint vertices;
    uint triangles;
} counters;

// Indirect drawing buffer
layout(std430, set = 1, binding = 2) buffer Indirect {
    uint vertex_count;
    uint instance_count;
    uint base_index;
    int vertex_offset;
    uint base_instance;
} indirect;

// Calculate the position for a vertex
vec3 calculate_vertex_position(uvec3 vertex) {
    return vec3(vertex);
}

// Add a new vertex to the mesh. Return its index
uint add_vertex(uvec3 vertex) {
    uint index = atomicAdd(counters.vertices, 1);
    vertices.data[index] = calculate_vertex_position(vertex);
    return index;
    
    /*
    ivec3 cell = ivec3(floor(vertex));
    uint loaded = atomicLoad(counters.vertices, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
    uint index = imageAtomicCompSwap(cached_indices, cell, 0, loaded);

    if (index == 0) {
        index = atomicAdd(counters.vertices, 1);
        vertices.data[index] = vertex;
    }

    return index;
    */
}

// Add a new quad to the mesh
void add_quad(
    uvec3 quad0,
    uvec3 quad1,
    uvec3 quad2,
    uvec3 quad3,
    bool flip
) {
    // Add the vertices
    uint index0 = add_vertex(quad0);
    uint index1 = add_vertex(quad1);
    uint index2 = add_vertex(quad2);
    uint index3 = add_vertex(quad3);

    // Add the triangles
    uint base = atomicAdd(counters.triangles, 6);
    
    // First triangle
    triangles.data[base + (flip ? 0 : 2)] = index2;
    triangles.data[base+1] = index1;
    triangles.data[base + (flip ? 2 : 0)] = index0;

    // Second triangle
    triangles.data[base + (flip ? 3 : 5)] = index3;
    triangles.data[base + 4] = index1;
    triangles.data[base + (flip ? 5 : 3)] = index2;

    atomicAdd(indirect.vertex_count, 6);
}

// Takes two values and find where x lies on them (0 - 1 range)
float unmix(float a, float b, float x)
{
    return (x - a) / (b - a);
}

// Checks an edge and creates new triangles if needed
void check_edge(
    uvec3 start,
    uvec3 end,
    uvec3 quad0,
    uvec3 quad1,
    uvec3 quad2,
    uvec3 quad3
) {
    // Get the densities of the edge
    float density0 = imageLoad(densities, ivec3(start)).x;
    float density1 = imageLoad(densities, ivec3(end)).x;

    // Check if the density functions represent solid matter or not
    bool positive0 = density0 > 0.0;
    bool positive1 = density1 > 0.0;

    // Create a quad if they do
    if ((positive0 ^^ positive1)) {
        add_quad(
            quad0 + uvec3(end),
            quad1 + uvec3(end),
            quad2 + uvec3(end),
            quad3 + uvec3(end),
            positive1
        );
    }
}

void main() {
    // Check the Z axis edge
    check_edge(
        gl_GlobalInvocationID,
        gl_GlobalInvocationID + uvec3(0, 0, 1),
        uvec3(0, 0, 0),
        uvec3(0, 1, 0),
        uvec3(1, 0, 0),
        uvec3(1, 1, 0)
    );
    
    // Check the X axis edge
    check_edge(
        gl_GlobalInvocationID,
        gl_GlobalInvocationID + uvec3(1, 0, 0),
        uvec3(0, 0, 0),
        uvec3(0, 0, 1),
        uvec3(0, 1, 0),
        uvec3(0, 1, 1)
    );

    // Check the Y axis edge
    check_edge(
        gl_GlobalInvocationID,
        gl_GlobalInvocationID + uvec3(0, 1, 0),
        uvec3(0, 0, 0),
        uvec3(1, 0, 0),
        uvec3(0, 0, 1),
        uvec3(1, 0, 1)
    );
}