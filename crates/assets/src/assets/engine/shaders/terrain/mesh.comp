#version 460 core
layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

#extension GL_KHR_memory_scope_semantics : require

// Data generated by the voxel comupute shader
layout(set = 0, binding = 0, r32f) readonly uniform image3D densities;

// Texture that contains the index of each vertex
layout(set = 0, binding = 1, r32ui) uniform uimage3D cached_indices;

// Output vertices
layout(std430, set = 0, binding = 2) writeonly buffer Vertices {
    vec3 data[32*32*32];
} vertices;

// Output triangles
layout(std430, set = 0, binding = 3) writeonly buffer Triangles {
    uint data[31*31*31*4];
} triangles;

// Atomic counters
layout(std430, set = 0, binding = 4) buffer Counters {
    uint vertices;
    uint triangles;
} counters;

// Indirect drawing buffer
layout(std430, set = 0, binding = 5) buffer Indirect {
    uint vertex_count;
    uint instance_count;
    uint base_index;
    int vertex_offset;
    uint base_instance;
} indirect;

// Add a new vertex to the mesh. Return its index
uint add_vertex(vec3 vertex) {
    uint index = atomicAdd(counters.vertices, 1);
    vertices.data[index] = vertex;
    return index;
    
    /*
    ivec3 cell = ivec3(floor(vertex));
    uint loaded = atomicLoad(counters.vertices, gl_ScopeDevice, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
    uint index = imageAtomicCompSwap(cached_indices, cell, 0, loaded);

    if (index == 0) {
        index = atomicAdd(counters.vertices, 1);
        vertices.data[index] = vertex;
    }

    return index;
    */
}

// Add a new quad to the mesh
void add_quad(
    vec3 quad0,
    vec3 quad1,
    vec3 quad2,
    vec3 quad3,
    bool flip
) {
    // Add the vertices
    uint index0 = add_vertex(quad0);
    uint index1 = add_vertex(quad1);
    uint index2 = add_vertex(quad2);
    uint index3 = add_vertex(quad3);

    // Add the triangles
    uint base = atomicAdd(counters.triangles, 6);
    
    // First triangle
    triangles.data[base + (flip ? 0 : 2)] = index2;
    triangles.data[base+1] = index1;
    triangles.data[base + (flip ? 2 : 0)] = index0;

    // Second triangle
    triangles.data[base + (flip ? 3 : 5)] = index3;
    triangles.data[base + 4] = index1;
    triangles.data[base + (flip ? 5 : 3)] = index2;

    atomicAdd(indirect.vertex_count, 6);
}

float unlerp(float a, float b, float x)
{
    return (x - a) / (b - a);
}

// Checks an edge and creates new triangles if needed
void check_edge(
    uvec3 start,
    uvec3 end,
    vec3 quad0,
    vec3 quad1,
    vec3 quad2,
    vec3 quad3,
    bool flip
) {
    float density0 = imageLoad(densities, ivec3(start)).x;
    float density1 = imageLoad(densities, ivec3(end)).x;
    bool positive0 = density0 > 0.0;
    bool positive1 = density1 > 0.0;

    if (positive0 ^^ positive1) {
        float guess = unlerp(density0, density1, 0.0);
        vec3 pos = mix(vec3(start), vec3(end), guess);
        uint index0 = add_vertex(pos);
        uint base = atomicAdd(counters.triangles, 3);
        triangles.data[base] = index0;
        triangles.data[base+1] = index0;
        triangles.data[base+2] = index0;
        atomicAdd(indirect.vertex_count, 3);
        /*
        add_quad(
            quad0 + vec3(start),
            quad1 + vec3(start),
            quad2 + vec3(start),
            quad3 + vec3(start),
            (flip ? positive1 : !positive1)
        );
        */
    }
}

const uvec3 edge_positions1[12] =
{
    uvec3(0, 1, 0),
    uvec3(1, 1, 0),
    uvec3(1, 0, 0),
    uvec3(1, 0, 0),
    uvec3(0, 1, 1),
    uvec3(1, 1, 1),
    uvec3(1, 0, 1),
    uvec3(0, 0, 1),
    uvec3(0, 0, 1),
    uvec3(0, 1, 1),
    uvec3(1, 1, 1),
    uvec3(1, 0, 1)
};

const uvec3 edge_positions2[12] =
{
    uvec3(0, 0, 0),
    uvec3(0, 1, 0),
    uvec3(1, 1, 0),
    uvec3(0, 0, 0),
    uvec3(0, 0, 1),
    uvec3(0, 1, 1),
    uvec3(1, 1, 1),
    uvec3(1, 0, 1),
    uvec3(0, 0, 0),
    uvec3(0, 1, 0),
    uvec3(1, 1, 0),
    uvec3(1, 0, 0)
};

void main() {
    check_edge(
        gl_GlobalInvocationID,
        gl_GlobalInvocationID + uvec3(0, 0, 1),
        vec3(0, 0, 0),
        vec3(0, 1, 0),
        vec3(1, 0, 0),
        vec3(1, 1, 0),
        false
    );
    

    /*
    check_edge(
        gl_GlobalInvocationID,
        gl_GlobalInvocationID + uvec3(0, 0, 1),
        vec3(0, 0, 0),
        vec3(0, 1, 0),
        vec3(1, 0, 0),
        vec3(1, 1, 0),
        false
    );
    */
}