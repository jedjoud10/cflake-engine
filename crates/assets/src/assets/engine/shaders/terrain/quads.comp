#version 460 core
layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

// TODO: Please implement spec constants instead of this shit
#include "size"

// Data generated by the voxel comupute shader
layout(set = 0, binding = 0, r32f) readonly uniform image3D densities;

// Texture that contains the index of each vertex
layout(set = 0, binding = 1, r32ui) readonly uniform uimage3D cached_indices;

// Output temp triangles
layout(std430, set = 1, binding = 0) writeonly buffer Triangles {
    uint data[(size - 1)*(size - 1)*(size - 1)*4*6];
} triangles;

// Atomic counters
layout(std430, set = 0, binding = 2) buffer Counters {
    uint vertices;
    uint triangles;
} counters;

// Indirect drawing buffer
layout(std430, set = 1, binding = 1) buffer Indirect {
    uint vertex_count;
    uint instance_count;
    uint base_index;
    int vertex_offset;
    uint base_instance;
} indirect;

// Add a new quad to the mesh
void add_quad(
    uvec3 quad0,
    uvec3 quad1,
    uvec3 quad2,
    uvec3 quad3,
    uvec3 offset,
    bool flip
) {
    // Add the vertices
    uint index0 = uint(imageLoad(cached_indices, ivec3(quad0+offset)).x);
    uint index1 = uint(imageLoad(cached_indices, ivec3(quad1+offset)).x);
    uint index2 = uint(imageLoad(cached_indices, ivec3(quad2+offset)).x);
    uint index3 = uint(imageLoad(cached_indices, ivec3(quad3+offset)).x);

    // Add the triangles
    atomicAdd(counters.triangles, 6);
    uint base = atomicAdd(indirect.vertex_count, 6);
    
    // First triangle
    triangles.data[base + (flip ? 0 : 2)] = index2;
    triangles.data[base+1] = index1;
    triangles.data[base + (flip ? 2 : 0)] = index0;

    // Second triangle
    triangles.data[base + (flip ? 3 : 5)] = index3;
    triangles.data[base + 4] = index1;
    triangles.data[base + (flip ? 5 : 3)] = index2;
}

// Checks an edge and creates new triangles if needed
void check_edge(
    uvec3 start,
    uvec3 end,
    uvec3 quad0,
    uvec3 quad1,
    uvec3 quad2,
    uvec3 quad3
) {
    // Get the densities of the edge
    float density0 = imageLoad(densities, ivec3(start)).x;
    float density1 = imageLoad(densities, ivec3(end)).x;

    // Create a quad if they do
    if ((density0 > 0.0 ^^ density1 > 0.0)) {
        add_quad(
            quad0,
            quad1,
            quad2,
            quad3,
            uvec3(end),
            density1 > 0.0
        );
    }
}

void main() {
    // Skip chunk faces since they will return incorrect data
    if (any(equal(gl_GlobalInvocationID, uvec3(0))) || any(equal(gl_GlobalInvocationID, uvec3(size - 1)))) {
        return;
    }

    // Check the Z axis edge
    check_edge(
        gl_GlobalInvocationID,
        gl_GlobalInvocationID + uvec3(0, 0, 1),
        uvec3(0, 0, 0),
        uvec3(0, 1, 0),
        uvec3(1, 0, 0),
        uvec3(1, 1, 0)
    );
    
    // Check the X axis edge
    check_edge(
        gl_GlobalInvocationID,
        gl_GlobalInvocationID + uvec3(1, 0, 0),
        uvec3(0, 0, 0),
        uvec3(0, 0, 1),
        uvec3(0, 1, 0),
        uvec3(0, 1, 1)
    );

    // Check the Y axis edge
    check_edge(
        gl_GlobalInvocationID,
        gl_GlobalInvocationID + uvec3(0, 1, 0),
        uvec3(0, 0, 0),
        uvec3(1, 0, 0),
        uvec3(0, 0, 1),
        uvec3(1, 0, 1)
    );
}