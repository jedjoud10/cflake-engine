#version 460 core
layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

#extension GL_KHR_memory_scope_semantics : require

// Data generated by the voxel comupute shader
layout(set = 0, binding = 0, r32f) readonly uniform image3D densities;

// Texture that contains the index of each vertex
layout(set = 0, binding = 1, r32ui) readonly uniform uimage3D cached_indices;

// Output triangles
layout(std430, set = 1, binding = 1) writeonly buffer Triangles {
    uint data[63*63*63*4];
} triangles;

// Atomic counters
layout(std430, set = 0, binding = 1) buffer Counters {
    uint vertices;
    uint triangles;
} counters;

// Add a new quad to the mesh
void add_quad(
    uvec3 quad0,
    uvec3 quad1,
    uvec3 quad2,
    uvec3 quad3,
    uvec3 offset,
    bool flip
) {
    // Add the vertices
    uint index0 = uint(imageLoad(cached_indices, ivec3(quad0)).x);
    uint index1 = uint(imageLoad(cached_indices, ivec3(quad1)).x);
    uint index2 = uint(imageLoad(cached_indices, ivec3(quad2)).x);
    uint index3 = uint(imageLoad(cached_indices, ivec3(quad3)).x);

    // Add the triangles
    uint base = atomicAdd(counters.triangles, 6);
    
    // First triangle
    triangles.data[base + (flip ? 0 : 2)] = index2;
    triangles.data[base+1] = index1;
    triangles.data[base + (flip ? 2 : 0)] = index0;

    // Second triangle
    triangles.data[base + (flip ? 3 : 5)] = index3;
    triangles.data[base + 4] = index1;
    triangles.data[base + (flip ? 5 : 3)] = index2;
}

// Checks an edge and creates new triangles if needed
void check_edge(
    uvec3 start,
    uvec3 end,
    uvec3 quad0,
    uvec3 quad1,
    uvec3 quad2,
    uvec3 quad3
) {
    // Get the densities of the edge
    float density0 = imageLoad(densities, ivec3(start)).x;
    float density1 = imageLoad(densities, ivec3(end)).x;

    // Create a quad if they do
    if ((density0 > 0.0 ^^ density1 > 0.0)) {
        add_quad(
            quad0,
            quad1,
            quad2,
            quad3,
            uvec3(end),
            density1 > 0.0
        );
    }
}

void main() {
    // Check the Z axis edge
    check_edge(
        gl_GlobalInvocationID,
        gl_GlobalInvocationID + uvec3(0, 0, 1),
        uvec3(0, 0, 0),
        uvec3(0, 1, 0),
        uvec3(1, 0, 0),
        uvec3(1, 1, 0)
    );
    
    // Check the X axis edge
    check_edge(
        gl_GlobalInvocationID,
        gl_GlobalInvocationID + uvec3(1, 0, 0),
        uvec3(0, 0, 0),
        uvec3(0, 0, 1),
        uvec3(0, 1, 0),
        uvec3(0, 1, 1)
    );

    // Check the Y axis edge
    check_edge(
        gl_GlobalInvocationID,
        gl_GlobalInvocationID + uvec3(0, 1, 0),
        uvec3(0, 0, 0),
        uvec3(1, 0, 0),
        uvec3(0, 0, 1),
        uvec3(1, 0, 1)
    );
}