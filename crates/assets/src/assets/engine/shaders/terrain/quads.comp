#version 460 core
layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

// Spec constants for size
layout (constant_id = 0) const uint size = 1;

// Data generated by the voxel comupute shader
layout(set = 0, binding = 0, rg32f) readonly uniform image3D voxels;

// Texture that contains the index of each vertex
layout(set = 0, binding = 1, r32ui) readonly uniform uimage3D cached_indices;

// Output temp triangles
layout(std430, set = 1, binding = 0) writeonly buffer Triangles {
    uint data[(size - 1)*(size - 1)*(size - 1)*4*6];
} triangles;

// Atomic counters
layout(std430, set = 0, binding = 2) buffer Counters {
    uint vertices;
    uint triangles;
} counters;

// Add a new quad to the mesh
void add_quad(
    uvec3 quad0,
    uvec3 quad1,
    uvec3 quad2,
    uvec3 quad3,
    uvec3 offset,
    bool flip
) {
    // Add the vertices
    uint index0 = uint(imageLoad(cached_indices, ivec3(quad0+offset)).x);
    uint index1 = uint(imageLoad(cached_indices, ivec3(quad1+offset)).x);
    uint index2 = uint(imageLoad(cached_indices, ivec3(quad2+offset)).x);
    uint index3 = uint(imageLoad(cached_indices, ivec3(quad3+offset)).x);

    // Add the triangles
    uint base = atomicAdd(counters.triangles, 6);
    
    // First triangle
    triangles.data[base + (flip ? 0 : 2)] = index2;
    triangles.data[base+1] = index1;
    triangles.data[base + (flip ? 2 : 0)] = index0;

    // Second triangle
    triangles.data[base + (flip ? 3 : 5)] = index3;
    triangles.data[base + 4] = index1;
    triangles.data[base + (flip ? 5 : 3)] = index2;
}

// Checks an edge and creates new triangles
void check_edge(
    float density0,
    uvec3 end,
    uvec3 quad0,
    uvec3 quad1,
    uvec3 quad2,
    uvec3 quad3,
    bool flip
) {
    // Get the densities of the edge
    float density1 = imageLoad(voxels, ivec3(end)).x;
    bool dir = (density1 > 0.0) ^^ flip;

    // Create a quad if they do
    if ((density0 > 0.0 ^^ density1 > 0.0)) {
        add_quad(
            quad0,
            quad1,
            quad2,
            quad3,
            uvec3(end),
            dir
        );
    }
}

void main() {
    // Skip chunk faces since they will return incorrect data
    if (any(equal(gl_GlobalInvocationID, uvec3(0))) || any(greaterThanEqual(gl_GlobalInvocationID, uvec3(size - 2)))) {
        return;
    }

    // Get the start density
    float density0 = imageLoad(voxels, ivec3(gl_GlobalInvocationID)).x;

    /*
    // Check skirts in the z direction
    if (gl_GlobalInvocationID.z == size - 3 || gl_GlobalInvocationID.z == 1) {
        check_edge(
            density0 + 3,
            gl_GlobalInvocationID + uvec3(0, 0, 1),
            uvec3(0, 0, 0),
            uvec3(0, 1, 0),
            uvec3(1, 0, 0),
            uvec3(1, 1, 0),
            gl_GlobalInvocationID.z == size - 3
        );
    }
    
    // Check skirts in the X direction
    if (gl_GlobalInvocationID.x == size - 3 || gl_GlobalInvocationID.x == 1) {
        check_edge(
            density0 + 3,
            gl_GlobalInvocationID + uvec3(1, 0, 0),
            uvec3(0, 0, 0),
            uvec3(0, 0, 1),
            uvec3(0, 1, 0),
            uvec3(0, 1, 1),
            gl_GlobalInvocationID.x == size - 3
        );
    }

    // Check skirts in the Y direction
    if (gl_GlobalInvocationID.y == size - 3 || gl_GlobalInvocationID.y == 1) {
        check_edge(
            density0 + 3,
            gl_GlobalInvocationID + uvec3(0, 1, 0),
            uvec3(0, 0, 0),
            uvec3(1, 0, 0),
            uvec3(0, 0, 1),
            uvec3(1, 0, 1),
            gl_GlobalInvocationID.y == size - 3
        );
    }
    */

    // Check the Z axis edge
    check_edge(
        density0,
        gl_GlobalInvocationID + uvec3(0, 0, 1),
        uvec3(0, 0, 0),
        uvec3(0, 1, 0),
        uvec3(1, 0, 0),
        uvec3(1, 1, 0),
        false
    );
    
    // Check the X axis edge
    check_edge(
        density0,
        gl_GlobalInvocationID + uvec3(1, 0, 0),
        uvec3(0, 0, 0),
        uvec3(0, 0, 1),
        uvec3(0, 1, 0),
        uvec3(0, 1, 1),
        false
    );

    // Check the Y axis edge
    check_edge(
        density0,
        gl_GlobalInvocationID + uvec3(0, 1, 0),
        uvec3(0, 0, 0),
        uvec3(1, 0, 0),
        uvec3(0, 0, 1),
        uvec3(1, 0, 1),
        false
    );
}